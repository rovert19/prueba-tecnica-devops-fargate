name: Build image and deploy

on:
  push:
    branches: [main]

env:
    AWS_REGION: us-east-1
    ECR_REPOSITORY: react-web-app
    ECS_CLUSTER: WebCluster
    TASK_DEFINITION: task-deploy-react-app-image
    ECS_SERVICE: react-web-service

jobs:
    build-image:
        name: Build image app
        runs-on: ubuntu-latest
        outputs:
          image: ${{ steps.build-push-image.outputs.image }}
        steps:
            - name: Checkout Repository
              uses: actions/checkout@v4
              with:
                fetch-depth: 0 
                
            - name: Configure AWS credentials
              uses: aws-actions/configure-aws-credentials@v1
              with:
                aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
                aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
                aws-region: ${{ env.AWS_REGION }}
                
            - name: SonarCloud Scan
              uses: sonarsource/sonarqube-scan-action@v4
              env:
                SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
              with:
                projectBaseDir: web-page-deploy-devops/src
                args: >
                  -Dsonar.organization=rovert19
                  -Dsonar.projectKey=rovert19_prueba-tecnica-devops-fargate
                  -Dsonar.verbose=true
                        
            - name: Check Quality Status
              id: check-quality-status
              uses: rovert19/sonarcloud-quality-check@v0.1
              with:
                sonar-project-key: rovert19_prueba-tecnica-devops-fargate
                sonar-token: ${{ secrets.SONAR_TOKEN }}
                branch: main
                
            - name: Quality Status Result
              run: |
                echo "${{ steps.check-quality-status.outputs.project-status }}"
                            
            - name: Login to ECR
              id: login-aws-ecr
              uses: aws-actions/amazon-ecr-login@v2
            
            - name: Build and push docker image to ECR
              id: build-push-image
              env:
                REGISTRY: ${{ steps.login-aws-ecr.outputs.registry }}
                IMAGE_TAG: ${{ github.sha }}
              run: |
                docker build -t $REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG .
                docker push $REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG
                echo "image=$REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
    
    deploy:
      name: Deploy image in AWS Fargate
      runs-on: ubuntu-latest
      needs: build-image
      steps:
        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v1
          with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_KEY }}
           aws-region: ${{ env.AWS_REGION }}

        - name: Get task definition 
          run: |
            aws ecs describe-task-definition --task-definition ${{ env.TASK_DEFINITION }} \
              --query taskDefinition --output json > task-definition.json

        - name: Register new revision from task definition
          id: new-task-def
          env:
            IMAGE: ${{needs.build-image.outputs.image}}
          run: |
            readlink -f task-definition.json
            CONTAINER_DEFINITIONS=`jq '.containerDefinitions[0].image = "$(IMAGE)"' task-definition.json | jq '.containerDefinitions'`
            echo $CONTAINER_DEFINITIONS
            aws ecs register-task-definition --container-definitions $CONTAINER_DEFINITIONS \
              --family ${{ env.TASK_DEFINITION }} --query taskDefinition > new-task.definition.json
            
            PATH_FILE=`readlink -f new-task-definition.json`
            echo "path_file=$(readlink -f new-task-definition.json)" >> $GITHUB_OUTPUT
        
        - name: Deploy to ECS Service
          uses: aws-actions/amazon-ecs-deploy-task-definition@v2
          with:
            task-definition: ${{ steps.new-task-def.outputs.path_file }}
            service: ${{ env.ECS_SERVICE }}
            cluster: ${{ env.ECS_CLUSTER }}
            wait-for-service-stability: true
